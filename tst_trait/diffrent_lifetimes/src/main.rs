// * 通过传递拥有不同具体生命周期的引用来限制 longest 函数的使用
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
      let string2 = String::from("xyz");
      // result = longest(string1.as_str(), string2.as_str());
      result = longest<&str>(string1.as_str(), string2);
      // * 上述代码中, string1在外部作用域结束之前都是有效的, 而string2则在内部作用于中是有效的, result也是在内部作用域结束都有效的值。因此他是可以通过编译的
      // * 下面将换一个方式, 将result的声明放到外部作用域中, 但是赋值表达式却在内部, 同时打印语句也放到了外部, 此时这个代码是无法通过编译的
      // * 因为在打印时, result语句已经失效了, 因为rust认为 string2需要直到外部作用于结束都是有效的才行
      // * 从人的角度上读这段代码, 我们可能会觉得这个代码是正确的。 string1的生命周期更长, 因此result会包含指向 string1的引用。因为 string1尚未离开作用域
      // * 对于 println! 来说 string1 的引用仍然是有效的。
      // * 然而, 我们通过生命周期告诉Rust的是: longest函数返回的引用的生命周期应该与传入参数的生命周期中较短的保持一致。因此检查器不允许代码运行, 因为他可能会存在无效的引用
      // println!("the longest string is {}", result);
    }
    // println!("the longest string is {}", result);
}

// * 但是上面的例子中, string1的生命周期比string2更长, 而string2确更早被回收了, 因此不能将两个参数的生命周期声明成同一个, 否则通不过检查器

// ! 深入理解生命周期
// ? + 指定生命周期参数的正确方式依赖函数实现的具体功能。
// * 无法指定生命周期参数来改变悬垂引用，而且 Rust 也不允许我们创建一个悬垂引用。在函数内部返回值是函数内部创建的值的情况下，最好的解决方案是返回一个有所有权的数据类型而不是一个引用，这样函数调用者就需要负责清理这个值了。
// ! 综上，生命周期语法是用于将函数的多个参数与其返回值的生命周期进行关联的。一旦他们形成了某种关联，Rust 就有了足够的信息来允许内存安全的操作并阻止会产生悬垂指针亦或是违反内存安全的行为。
// * 所以新的 longest 不需要生命周期注释, 他的返回值应该是内部接收的一个新的值, 直接将这个带有所有权的值抛出即可
/* 
  ? + 从函数返回引用时, 返回类型的生命周期参数必须要与其中一个参数的生命周期相匹配:  
  ? + 如果返回的引用没有指向任何参数, 那么它只能引用函数内创建的值
  ? - 这就是悬垂引用: 该值在函数结束时就走出了作用域
*/
