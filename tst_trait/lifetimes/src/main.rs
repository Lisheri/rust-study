// * 函数中的泛型生命周期
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    // * 将字符串对象转变为字符串字面量
    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);

    // * 引用
    // TODO &i32;
    // * 带有显式生命周期注解的不可变引用
    // TODO &'a i32
    // * 带有显式生命周期的可变引用
    // TODO &'a mut i32
}
// * 实现(添加生命周期注解)
/*
 * 单个生命周期注解本身没有多少意义, 因为生命周期注解告诉Rust多个引用的泛型生命周期参数如何相互联系的
 * 例如如果函数有一个生命周期 'a 的 i32 的引用参数 first。还有另一个同样是生命周期 'a 的 i32 的引用参数 second
 * 这两个生命周期注解意味着引用 first 和 second 必须与这泛型生命周期存在得一样久
 * 下面的例子表达的就是x和y存活的时间是一样的
 * 它的实际含义是 longest 函数返回的引用的生命周期与传入该函数的引用的生命周期的较小者一致, 这些关系就是我们希望 Rust 分析代码时所使用的
 * 
 * 当具体的引用被传递给 longest 时，被 'a 所替代的具体生命周期是 x 的作用域与 y 的作用域相重叠的那一部分。
 * 换一种说法就是泛型生命周期 'a 的具体生命周期等同于 x 和 y 的生命周期中较小的那一个。
 * 因为用相同的生命周期参数 'a 标注了返回的引用值，所以返回的引用值就能保证在 x 和 y 中较短的那个生命周期结束之前保持有效。
 */
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        return x;
    } else {
        return y;
    }
}
// * 但是上述实现会报错, 因为Rust并不知道 longest 具体是返回的x 还是 y的引用, 事实上, 开发者也不知道
// ? 为了修复上面的这个错误, 需要增加泛型生命周期参数, 来定义引用建的关系, 以便借用检查器可以进行分析

/*
  生命周期注解语法
  生命周期注解语法并不能改变任何引用的生命周期的长短
  与函数签名中指定了泛型类型参数后就可以接受任何类型一样, 当指定了泛型生命周期后函数也能接受任何生命周期的引用。
*/

// * 生命周期注解语法: 以 撇号(') 开头, 全称通常全是小写, 类似于泛型起名称非常短。
// * 'a 是大多数人默认使用的名称
// * 生命周期参数注解 位于引用的 & 之后, 并有一个空格来将引用类型与生命周期注解分隔开

/* 
  ! 记住通过在函数签名中指定生命周期参数时，我们并没有改变任何传入值或返回值的生命周期，而是指出任何不满足这个约束条件的值都将被借用检查器拒绝。
  ! 和类型泛型一样, 生命周期泛型仅仅只是约束生命周期, 而不是改变生命周期

  当在函数中使用生命周期注解时，这些注解出现在函数签名中，而不存在于函数体中的任何代码中。生命周期注解成为了函数约定的一部分，非常像签名中的类型。
  这样做简化了编译器的工作, 只要注解不对或者调用方法不对, 编译器可以准确指出错误的位置和原因, 如果不这样, 那么编译器的报错, 可能会差之千里
*/
