fn main() {
    // * 所有权(系统)是Rust最与众不同的特性, 对语言的其他部分有着深刻含义。它让Rust无需垃圾回收(gc)即可保障内存安全, 因此理解Rust中所有权如何工作是十分重要的。
    // * 所有权相关功能又: 借用(borrowing)、slice以及Rust如何在内存中布局数据

    // ? 1.所有权(ownership) 对语言的其他部分有着深刻的影响
    // * 所有程序都必须管理其运行时使用计算机内存的方式。
    // * 1. 一些语言中具有垃圾回收机制, 在程序运行时不断的寻找不再使用的内存, 如 js(v8)
    // * 2. 另一些语言中, 程序员必须亲自分配和释放内存。如 C
    // * 然而Rust选择了第三种方式: 通过所有权系统管理内存, 编译器在编译时会根据一系列的规则进行检查。如果违反了任何这些规则, 程序都不能编译。运行时, 所有权系统的任何功能都不能减慢程序。

    // * 回顾一下堆(Heap)栈(Stack)
    // * 在Rust中, 值是位于栈上还是堆上, 在更大成都上影响了语言的行为以及为何必须做出这样的抉择。
    // * 堆和栈都是代码运行时可供选择的内存, 但是他们的结构不同。
    // * 栈以放入值的顺序存储值并以相反顺序取出, 也就是所谓的 "先进后出"
    // * 出栈、入栈都走栈顶。
    // * 栈中所有数据都必须占用已知且固定的大小。
    // * 在编译时, 大小未知或大小可能发生变化的数据将会存储到堆上
    // * 堆是无序的: 向 堆 中存储数据时, 要先请求一定大小的空间。内存分配器在堆的某处找到一块足够大的空位, 把它标记为已使用, 并返回一个表示该位置地址的 "指针"(pointer)。这个过程称作: 在堆上分配内存, 有时简称为: "分配"(allocating), 所以说分配操作, 一定发生在堆内存开辟时
    // ! 将数据推入栈并不被认为是 "分配"。因为指针的大小是已知且固定的, 可以将指针存储在栈上, 不过当需要实际数据时, 必须访问指针。
    // ? "分配" 更像是去餐馆就座吃饭。当进入时，你说明有几个人，餐馆员工会找到一个够大的空桌子并领你们过去。如果有人来迟了，他们也可以通过询问来找到你们坐在哪。
    // * 入栈操作比在堆上分配内存要快, 因为分配器无需为存储新数据去搜索内存空间; 位置总是在栈顶。相比之下, 在堆上分配内存则需要更多的工作, 这是因为分配器必须首先找到一块足够存放数据的内存空间, 并接着做一些记录为下一次分配做准备。
    // * 访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。
    /*
      访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。现代处理器在内存中跳转越少就越快（缓存）。
      继续类比，假设有一个服务员在餐厅里处理多个桌子的点菜。在一个桌子报完所有菜后再移动到下一个桌子是最有效率的。从桌子 A 听一个菜，接着桌子 B 听一个菜，然后再桌子 A，然后再桌子 B 这样的流程会更加缓慢。
      出于同样原因，处理器在处理的数据彼此较近的时候（比如在栈上）比较远的时候（比如可能在堆上）能更好的工作。在堆上分配大量的空间也可能消耗时间。

      当代码调用一个函数时, 传递给函数的值(包括可能指向堆上数据的指针)和函数的局部变量被压入栈, 当函数结束时, 这些值出栈(这个叫函数调用栈, 和v8类似)

      ?1. 跟踪哪部分代码正在使用堆上的哪些数据; 2. 最大限度的减少堆上的重复数据的数量; 3. 清理堆上不再使用的数据确保不会耗尽空间; 以上这些问题正是所有权系统要处理的。
      一旦理解了所有权，你就不需要经常考虑栈和堆了，不过明白了所有权的主要目的就是为了管理 "堆数据"， 能够帮助解释为什么所有权要以这种方式工作。
    */

    // ? 所有权规则:
    /*
      ? 1. Rust中每一个值都有一个被称为其 所有者(owner)的变量
      ? 2. 值在任一时刻有且只有一个所有者(比如一个指针作为函数入参, 在一个函数(线程)执行时, 其余函数(线程)不能操作该指针)
      ? 3. 当所有者(变量) 离开作用域, 这个值将被丢弃。
    */

    // ? 变量作用域
    // * 作用域(scope): 是一个 项(item) 在程序中有效的范围。(类似于JS的块级作用域)

    // ! 字符串值是不可变的 且 并非所有字符串的值都能在编写代码时就知道

    /*
      例如，要是想获取用户输入并存储该怎么办呢？为此，Rust 有第二个字符串类型，String。这个类型管理被分配到堆上的数据，所以能够存储在编译时未知大小的文本。可以使用 from 函数基于字符串字面值来创建 String，如下：
    */
    let s = String::from("hello");
    // * 上述冒号 :: 是运算符, 允许将特定的 from 函数置于 String 类型的命名空间(namespace)下, 而不需要使用类似 string_from 这样的名字
    // * 字符串 s是可变的, 置于为什么, 接后续

    // ? 内存与分配
    // * 就字符串字面值来说, 在编译时知道起内容, 所以文本被直接硬编码进最终的可执行文件中。这使得字符串字面值快速且搞笑。不过这些特性都只得益于字符串字面值的不可变性。不幸的是, 我们不能为了每一个在编译时大小未知的文本而将一块内存放入二进制文件中, 并且它的大小还可能随着程序运行而改变。

    /*
    对于String而言, 为了支持一个可变, 可增长的文本片段, 需要在堆上分配一块在编译时未知代销的内存来存放内容, 这意味着：
    1. 必须在运行时向内存分配器请求内存
    2. 需要一个当我们处理完 String 时将内存返回给内存分配器的方法

    第一部分由开发者完成, 在调用 String::from 时, 它的实现 请求其所需的内存。这在编程语言中是通用的
    第二部分实现起来就各有区别, 在有gc的语言中, gc记录并清除不再使用的内存(标记清除法), 而开发者不需要关注。在大部分没有GC的语言中, 识别出不在使用的内存, 并调用代码显示释放就是开发人员的责任, 和请求内存一样(如C等)
    从历史的角度上说正确处理内存回收曾经是一个困难的编程问题。如果忘记回收了会浪费内存。如果过早回收了，将会出现无效变量。如果重复回收，这也是个 bug。我们需要精确的为一个 allocate 配对一个 free

    但是在rust中, 采取了不同的策略: 内存在拥有它的变量离开作用域后就被自动释放。如下:
    */

    /* {
        let s = String::from("hello"); // 从此处起，s 是有效的

        // 使用 s
    } */

    /*
      上述是一个将 String 需要的内存返回给分配器的自然的位置： 当 s 离开作用域时。
      当变量离开作用域, Rust为开发人员调用了一个特殊的函数, 叫做 drop， 当然, 在此处 String的开发人员可以放置释放内存的代码。 但是在 Rust结尾的 "}" 会自动调用 drop
    */
    /*
      注意：在 C++ 中，这种 item 在生命周期结束时释放资源的模式有时被称作： "资源获取即初始化（Resource Acquisition Is Initialization (RAII)）"。如果你使用过 RAII 模式的话应该对 Rust 的 drop 函数并不陌生。
    */

    // ? 变量与数据交互的方式(一): 移动
    /*
      let x = 5;
      let y = x;
    */
    /*
      两个5都被放入栈中
    */

    // * String版本
    /*
      let s1 = String:from("hello");
      let s2 = s1;
    */

    /*
      这个是将s1的指针赋值给了s2, 当s2发生变化时, s1跟随变化(因为他们本质上都指向同一个引用地址)
      (这个概念和js的引用数据类型类似, 变量存储在栈上, 值是一个指针, 指向堆中的地址)
      s2 = s1 这个赋值操作发生时, 只是将s1在栈上的 [value(指针), 长度, 内存空间]完全赋值给了s2

      这个也是因为性能因素, 才选择了复制栈而不是直接复制堆, 重新开辟一块堆内存
    */

    /*
      上述操作就带来了一个问题：
      当 s2 和 s1 离开作用域，他们都会尝试释放相同的内存。
      这是一个叫做 二次释放（double free）的错误，也是之前提到过的内存安全性 bug 之一。
      两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。
    */

    /*
      为了确保内存安全，这种场景下 Rust 的处理有另一个细节值得注意。
      与其尝试拷贝被分配的内存，Rust 则认为 s1 不再有效，
      因此 Rust 不需要在 s1 离开作用域后清理任何东西。
      看看在 s2 被创建之后尝试使用 s1 会发生什么；这段代码不能运行：

      let s1 = String::from("hello");
      let s2 = s1;
      println!("{}, world!", s1);

      上述代码会直接报错, 因为在打印语句执行后, 没有s2的使用, 因此在 let s2 = s1; 结束时, s2实际上就已经被移除回收了, 同时s1也就没有了
    */

    /*
      浅拷贝 和 移动的不同点, 就在于Rust中的 移动 会使第一个变量无效, 因此他并非浅拷贝, 所以上面的例子应该说是 s1 移动到了 s2 中(浅拷贝会有开辟新的栈顶空间, 移动不会)

      另外，这里还隐含了一个设计选择：Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何 自动 的复制可以被认为对运行时性能影响较小。
    */

    // ? 变量与数据交互的方式(二): 克隆(深拷贝)

    /*
      let s1 = String::from("hello");
      let s2 = s1.clone();
      println!("s1 = {}, s2 = {}", s1, s2);
    */

    // ? 变量与数据交互的方式(三): 拷贝
    /*
      那么什么类型是 Copy 的呢？可以查看给定类型的文档来确认，不过作为一个通用的规则，任何简单标量值的组合可以是 Copy 的，不需要分配内存或某种形式资源的类型是 Copy 的。如下是一些 Copy 的类型：

      所有整数类型，比如 u32。
      布尔类型，bool，它的值是 true 和 false。
      所有浮点数类型，比如 f64。
      字符类型，char。
      元组，当且仅当其包含的类型也都是 Copy 的时候。比如，(i32, i32) 是 Copy 的，但 (i32, String) 就不是。
    */

    // ? 所有权与函数
    // * 将值传递给函数在语义上与给变量赋值相似, 向函数传递值可能会移动或赋值, 就像赋值语句一样。

    /*
      fn main() {
          let s = String::from("hello");  // s 进入作用域

          takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效

          let x = 5;                      // x 进入作用域

          makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x

      } // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
    // 所以不会有特殊操作

      fn takes_ownership(some_string: String) { // some_string 进入作用域
          println!("{}", some_string);
      } // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

      fn makes_copy(some_integer: i32) { // some_integer 进入作用域
          println!("{}", some_integer);
      } // 这里，some_integer 移出作用域。不会有特殊操作
    */

    /*
      当尝试在调用 takes_ownership 后使用 s 时，Rust 会抛出一个编译时错误。这些静态检查使我们免于犯错。试试在 main 函数中添加使用 s 和 x 的代码来看看哪里能使用他们，以及所有权规则会在哪里阻止我们这么做。
    */

    // ? 返回值与作用域

    // * 返回值也可以转移所有权

    /*
      !变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。
      在每一个函数中都获取所有权并接着返回所有权有些啰嗦。如果我们想要函数使用一个值但不获取所有权该怎么办呢？如果我们还要接着使用它的话，每次都传进去再返回来就有点烦人了，除此之外，我们也可能想返回函数体中产生的一些数据。
    */

    // ! 由于上面这种所有值移动或者被drop的场景非常常见, 但是这样会极大的影响开发体验, 因此, Rust 对此提供了一个功能, 叫做 引用(references)

    // ? 引用与借用
    // * 在引用概念出现之前, 我们必须将入参在函数结束后返回出去, 并且用一个变量接收, 这样非常的(愚蠢)
    // * 可以使用引用, 解决该问题, 让堆变量入参不是 移动 而是拷贝

    /*
      fn main() {
        let s1 = String::from("hello");
        let len = calculate_length(&s1);
        println("The length of '{}' is {}.", s1, len);
      }
      fn calculate_length(s: &String) -> usize {
          return s.len();
      }
    */

    // * 上述代码中, 注意变量声明和函数返回值中的所有元组代码消失了, 其次, 传递 &s1 给 calculate_length, 同时在函数定义中, 获取的是 &String 而不是 String

    // * 上面的 & 符号, 就是引用, 它允许使用值但不获取其所有权。

    // ! 注: 与使用 & 引用相反的操作是 解引用（dereferencing），它使用解引用运算符: *。

    // * &s1 语法让我们创建一个 指向 值 s1 的引用，但是并不拥有它。因为并不拥有这个值，当引用离开作用域时其指向的值也不会被丢弃。

    // * 同理，函数签名使用 & 来表明参数 s 的类型是一个引用。

    /*
      fn calculate_length(s: &String) -> usize { // s 是对 String 的引用
          s.len()
      } // 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，
      所以什么也不会发生, 也就不会drop(s)了
    */

    // ? 借用: 我们将获取引用作为函数参数称为 借用（borrowing）。正如现实生活中，如果一个人拥有某样东西，你可以从他那里借来。当你使用完毕，必须还回去。
    // ! 注: 借用的变量, 不能在函数内部修改他的值, 正如变量默认是不可变的，引用也一样, 默认情况下不允许修改引用的值

    // ? 于是产生了 -> 可变引用(&mut)
    // * 使用可变引用的前提是, 变量本身也是可变的才行, 因此 let mut s = String::from("hello"); change(&mut s); fn change(some_string: &mut String) {some_string.push_str(", world!");}
    // ! 不过可变引用有一个很大的限制: 在特定作用域中的特定数据只能有一个可变引用

    // ! 虽然有点蠢, 但是这个限制也有一定的好处, 就是 Rust 在编译时就避免了 数据竞争。
    // ? 数据竞争类似于 竞态条件, 由三个行为造成: 1. 两个或更多指针同时访问同一内存地址 2. 至少有一个指针被用来写入数据 3. 没有同步数据的访问机制
    // ? 数据竞争会导致未定义行为，难以在运行时追踪，并且难以诊断和修复；Rust 避免了这种情况的发生，因为它甚至不会编译存在数据竞争的代码！

    // ? 解决上述问题, 最方便的方式是, 使用 花括号创建更多的作用域, 以拥有多个可变引用, 只是不能 同时 拥有
    // ? 当然, 同一作用域中, 也不能同时持有可变和非可变引用(主要是不能出现可变引用和其他的引用指向同一地址), 同时定义的新的引用, 在使用后, 这个存储引用的变量同样会被回收, 只是不回收引用罢了(因为他不是移动)

    // ? 悬垂引用
    // * 在具有指针的语言中, 很容易通过释放内存时保留指向它的指针而错误地生成一个 悬垂指针
    // * 所谓的悬垂指针, 也就是 其指向的内存可能已经被分配给其他持有者。
    // * 当然, 在Rust中, 编译器确保引用永远也不会变成悬垂状态, 当拥有一些数据的引用, 编译器会确保数据不会在其引用之前离开作用域(会通过报错来防止这样的情况, 如下)
    /* fn main() {
        let reference_to_nothing = dangle();
    }

    fn dangle() -> &String {
        let s = String::from("hello");

        &s
        上面这个返回值会直接报错, 因为s处于函数作用域内, 函数执行完, 是一定要回收的, 此时这个&s的指向已经发生变化, 指向了null, 这个在Rust中是不允许的, 直接报错(粗暴)
    } */

    // * 引用的规则:
    // * 1. 在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。
    // * 2. 引用必须总是有效的。
}
