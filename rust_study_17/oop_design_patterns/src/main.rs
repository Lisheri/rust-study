/* 
    面向对象设计模式的部分实现

    * 状态模式
    + 是一个面向对象的设计模式。
    + 关键在于一个值有某些内部状态, 体现为一系列的状态对象, 同时值的行为随着内部状态而改变
    + 使用状态模式意味着当程序的业务需求改变时，无需改变值持有状态或者使用值的代码。只需更新某个状态对象中的代码来改变其规则，或者是增加更多的状态对象

    例: 为了探索上述概念, 将实现一个增量式的发布博文的工作流

    + 1. 博文从空白的草案开始
    + 2. 一旦草案完成, 请求审核博文
    + 3. 一旦博文过审, 它将被发表
    + 4. 只有被发表的博文的内容会被打印, 这样就不会以外打印出没有被审核的博文的文本
*/
use oop_design_patterns::modules::blog::Post;
fn main() {
    // * new方法创建新的博文草案。也希望在草案阶段为博文编写一些文本。
    // * 如果在审批之前尝试立即获取博文的内容, 不应该获取到任何文本, 因为博文仍然是草案
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    // * 此处一个好的单元测试应该断言 草案博文的 content 方法返回空的字符串, 不过这里并不准备为这个例子编写单元测试
    assert_eq!("", post.content());

    // * 接下来需要请求审核博文, 而在等待审核阶段, content应该依然返回空字符串
    post.request_review();
    assert_eq!("", post.content());

    // * 博文审核通过, 他应该被发表, 意味着 content应该返回对应的内容
    post.approve();
    assert_eq!("I ate a salad for lunch today", post.content());
    /* 
        注意我们与 crate 交互的唯一的类型是 Post。
        这个类型会使用状态模式并会存放处于三种博文所可能的状态之一的值 —— 草案，等待审核和发布。
        状态上的改变由 Post 类型内部进行管理。
        状态依库用户对 Post 实例调用的方法而改变，但是不能直接管理状态变化。
        这也意味着用户不会在状态上犯错，比如在过审前发布博文。
    */
}
