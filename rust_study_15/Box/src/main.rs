// * 使用 Box<T> 来指向 Heap上的数据
use crate::List::{Cons, Nil};

/*
    + Box<T> 是最简单的智能指针:
        - 允许你在 heap 上存储数据(而不是 stack)
        - 其实和js的引用类型(object)一样, 在stack上存储一个指向heap的指针, 真正的值是存储在heap上的
        - 没有性能开销
        - 同时他也没有额外功能

        - 它实现了 Deref trait 和 Drop trait
    + Box<T> 的常用场景
        - 在编译时, 某类型的大小无法确定。但使用该类型时, 上下文却需要知道它的确切大小。
        - 当你有大量数据, 想移交所有权, 但需要确保在操作时, 数据不会被复制
        - 使用某个值时, 你只关心它是否实现了特定的 trait, 而不关心它的具体类型
*/
fn main() {
    // * 使用 Box<T> 在 heap 上存储数据
    // 使用Box<T>可以像数据存储在stack上一样访问box中的数据, 正如拥有所有权的值一样, 变量在main的末尾离开作用域时, 将被释放。
    // 这个释放的过程作用于box本身(位于 stack 上)和它所指向的数据(位于 heap 上)
    let b = Box::new(5);
    println!("b = {}", b);

    // 使用Box赋能递归类型
    // + 在编译时, Rust需要知道一个类型所占的空间大小
    // + 而递归类型的大小无法在编译时确定, 因为这种值的嵌套理论上可以无限进行下去
    // + 不过 box 有一个已知的大小，所以通过在循环类型定义中插入 box，就可以创建递归类型了。

    // ? Cons list

    // cons list: 函数式编程语言中的常见类型, 来展示递归类型概念。
    // * cons list 是一个来源于 Lisp 编程语言及其方言的数据结构。
    // * 在 Lisp 中，cons 函数（“construct function" 的缩写）利用两个参数来构造一个新的列表，他们通常是一个单独的值和另一个列表。
    // * cons list 的每一项都包含两个元素：当前项的值和下一项。
    // * 其最后一项值包含一个叫做 Nil 的值且没有下一项。
    // * cons list 通过递归调用 cons 函数产生。
    // * 代表递归的终止条件(base case)的规范名称是Nil, 它宣布列表的终止。
    // * 不同于第六章中的 “null” 或 “nil” 的概念，他们代表无效或缺失的值。
    // * 其实就相当于是一种链表
    // * 通常情况下, Vec<T>是更好的选择

    // * 这就是使用Cons List的意图, 就是为了创建如下所示的一个链表
    // let list = Cons(1, Cons(2, Cons(3, Nil)));
    // 改造
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
    // println!("当前值为: {}" list);
}

// * 创建一个 Cons List
// * 创建了一个枚举
// * 但是这里有一个报错, 因为这个递归类型, 没有终止条件
// enum List {
//     Cons(i32, List),
//     Nil
// }

// * 这里展示一下Rust如何计算非递归类型的大小
/*
    当 Rust 需要知道要为 Message 值分配多少空间时，
    它可以检查每一个成员并发现 Message::Quit 并不需要任何空间，
    Message::Move 需要足够储存两个 i32 值的空间，依此类推。
    因为 enum 实际上只会使用其中的一个成员，所以 Message 值所需的空间等于储存其最大成员的空间大小。
    但是检查List枚举时, 开始检查Cons成员, 大小就是 i32 加上 List的大小, 为了计算List有多少内存, 检查其成员, 从Cons开始。
    Cons成员存储了一个i32和一个List, 这样计算将无限进行下去
*/
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

// * 使用Box<T>给递归类型一个已知的大小
// Rust 无法计算出要为定义为递归的类型分配多少空间，所以编译器会报错
// 在建议中，“indirection” 意味着不同于直接储存一个值，我们将间接的储存一个指向值的指针。
// 因为 Box<T> 是一个指针，我们总是知道它需要多少空间：指针的大小并不会根据其指向的数据量而改变。
// 这意味着 Box 放入 Cons成员中, 而不是直接存放另一个 List 值。Box会指向另一个位于堆上的List值, 而不是存放在 Cons 成员中。
// 从概念上讲, 我们仍然有一个通过在其中 "存放" 其他列表创建的列表, 不过现在实现这个概念的方式更像是一个项挨着另一项, 而不是一项包含另一项

// * 修改上述定义
/*
    Cons 成员将会需要一个 i32 的大小加上储存 box 指针数据的空间。
    Nil 成员不储存值，所以它比 Cons 成员需要更少的空间。
    现在我们知道了任何 List 值最多需要一个 i32 加上 box 指针数据的大小。
    通过使用 box ，打破了这无限递归的连锁，这样编译器就能够计算出储存 List 值需要的大小了。
*/
enum List {
    Cons(i32, Box<List>),
    Nil,
}

/*
    box 只提供了间接存储和堆分配；他们并没有任何其他特殊的功能，比如我们将会见到的其他智能指针。它
    们也没有这些特殊功能带来的性能损失，所以他们可以用于像 cons list 这样间接存储是唯一所需功能的场景。

    Box<T> 类型是一个智能指针，因为它实现了 Deref trait，它允许 Box<T> 值被当作引用对待。
    当 Box<T> 值离开作用域时，由于 Box<T> 类型 Drop trait 的实现，box 所指向的堆数据也会被清除。
    让我们更详细的探索一下这两个 trait。
    这两个 trait 对于在本章余下讨论的其他智能指针所提供的功能中，将会更为重要。
*/
