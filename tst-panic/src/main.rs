fn main() {
    println!("Hello, world!");
    // panic发生时候, 有两种情况
    // 默认情况下, 当panic发生时候,
    // 程序展开调用栈(工作量大), rust沿着调用栈往回走, 清理每个遇到的函数中的数据
    // 或者立即中止调用栈: 不进行清理, 直接停止程序; 内存需要OS进行清理

    // * 如果想让二进制文件更小, 可以把设置从展开改为中止;
    // - 在 Cargo.toml 中适当的 profile 部分设置:
    // panic = "abort"

    // panic! 宏运行, 直接打印错误信息, 执行panic操作
    // 其实很多panic, 就是panic!宏在内部函数执行, 只是没有暴露出来罢了
    // 通过调用 panic! 函数的回溯信息来定位引起问题的代码
    // * 就是通过设置环境变量 RUST_BACKTRACE 可得到回溯信息
    // ! 为了获取带有调试信息的回溯, 必须启用调试符号(cargo run)(不带--release, 其实默认就不带)
}
