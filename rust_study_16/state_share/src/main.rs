use std::sync::{Mutex, Arc};
use std::thread;
use std::rc::Rc;

/* 
    共享状态并发
    虽然消息传递是一个很好的处理并发的方式,  但并不是唯一一个。还的是Go中的口号: 不要通过共享内存来通讯

    在某种程度上, 任何编程语言中的通道都类似于单所有权, 因为一旦将一个值传送到通道中, 将无法在使用这个值。
    共享内存类似于多所有权: 多个线程可以同时访问相同的内存区域。

    智能指针使得多所有权成为可能, 然而这会增加额外的复杂性, 因为需要以某种方式管理这些不同的所有者。

    Rust 的类型系统和所有权规则极大的协助了正确地管理这些所有权。

    ! 如: 互斥器: 一个更为常见的共享内存并发原语。
*/
fn main() {
    // * 互斥器(mutex)是mutual exclusion缩写, 也就是说, 任意时刻只允许一个线程访问某些数据。
    /* 
        为了访问互斥器中的数据, 线程首先需要通过获取互斥器的 锁, 来表明其希望访问数据。锁是一个作为互斥器一部分的数据结构, 它记录谁有数据的排他访问权。
        锁是一个作为互斥器一部分的数据结构, 记录谁有数据的排他访问权。
        因此，我们描述互斥器为通过锁系统 保护其数据。

        互斥器以难以使用著称:
            + 在使用数据之前尝试获取锁
            + 处理完被互斥器所保护的数据滞后, 必须解锁数据, 这样其他线程才能够获取锁
        
        作为一个现实中互斥器的例子, 一个会议中抢麦, 只有一个麦克风, 一个成员要发言, 他必须请求或表示希望使用麦克风, 一旦得到麦克风, 就可以发言, 然后将麦克风交给下一个人。
        一旦一位成员发言完毕后忘记交还麦克风, 就会导致其他人无法发言。如果对共享麦克风的管理出了问题, 座谈会将无法继续

        正确的管理互斥器异常复杂，这也是许多人之所以热衷于通道的原因。然而，在 Rust 中，得益于类型系统和所有权，我们不会在锁和解锁上出错。
    */

    // * Mutex<T> API
    // * 互斥器, 单线程版本
    // let m = Mutex::new(5);
    // {
        // * 使用 lock()方法获得锁, 以访问互斥器中的数据。
        // * 这个调用会阻塞线程, 直到拥有锁为止
        // ! 如果另一个线程有锁, 并且另一个线程panic了, 则lock调用会失败, 这种情况下没有人能够再获取锁, 所以这里选择 unwrap 并在遇到这种情况时使线程panic
        // * 一旦获取了锁，就可以将返回值（在这里是num）视为一个其内部数据的可变引用了
        // * 类型系统确保在使用m中的值之前获取锁: Mutex<i32> 并不是一个 i32，所以 必须 获取锁才能使用这个 i32 值
        // * 如果不获取, 那么将不能访问i32
        // let mut num = m.lock().unwrap();
        // * 丢弃锁之后, 可以打印出互斥器的值, 并发现能够将其内部的 i32 修改为 6
        // *num = 6;
        /* 
            Mutex<T> 是一个智能指针。更准确的说，lock 调用 返回 一个叫做 MutexGuard 的智能指针。
            这个智能指针实现了 Deref 来指向其内部数据；其也提供了一个 Drop 实现当 MutexGuard 离开作用域时自动释放锁，这正发生于此处(内部作用域)的结尾。
            所以不会由于我们忘记释放锁并阻塞互斥器为其他线程所用的风险, 因为锁的释放是自动发生的
        */
    // }
    // println!("m = {:?}", m);

    /* 
        ! 线程间共享 Mutex<T>
        尝试使用 Mutex<T> 在多个线程之间共享值。这里将启动10个线程, 并在各个线程中对同一个计数器值 加1, 这样计数器将会从0变为10
    */

    // * 创建一个 counter 变量来存放内涵 i32 的 Mutex<T>
    // let counter = Rc::new(Mutex::new(0));
    let counter = Arc::new(Mutex::new(0));
    
    let mut handles = vec![];
    
    // * 遍历range创建10个线程。所有线程的回调函数均相同, 每一个都将调用 lock 方法来获取 Mutex<T>上的锁, 接着将互斥器中的值加一。
    // * 当线程执行结束, num会离开闭包作用域并释放锁, 这样另一个线程就可以获取它了

    // ? 这里会无法通过编译, rust会告诉我们不能将 counter锁 的所有权移动到多个线程中
    // ? 需要使用多所有权手段, 通过使用智能指针 Rc<T> 来创建引用计数的值，以便拥有多所有者
    // + 多线程和多所有权
    for _ in 0..10 {
        // let counter = Rc::clone(&counter);
        // ? 使用Arc<T>
        let counter = Arc::clone(&counter);
        // * 使用Rc克隆所有权依然会报错, the trait `Send` is not implemented for `Rc<Mutex<i32>>`
        // * trait Send 确保所使用的类型可以用于并发环境的trait之一
        // * 而 Rc<T> 并不能安全的在线程间共享。当 Rc<T> 管理引用计数时, 它必须在每一个 clone 调用时增加计数, 并在每一个克隆被丢弃时减少计数。
        // * Rc<T>并没有使用任何并发原语, 来确保改变计数的操作不会被其他线程打断。在计数出错时可能会导致诡异的bug, 比如可能造成内存泄漏, 或在使用结束之前就丢弃一个值。、
        // * 所以这里其实是需要一个完全类似Rc<T>, 又以一种线程安全的方式改变引用计数的类型

        // + 原子引用计数 Arc<T>
        // * Arc<T> 正是 这么一个类似 Rc<T> 并可以安全的用于并发环境的类型。
        // * 字母 “a” 代表 原子性（atomic），所以这是一个原子引用计数（atomically reference counted）类型。
        // * 原子性是另一类这里还未涉及到的并发原语：请查看标准库中 std::sync::atomic 的文档来获取更多细节。其中的要点就是：原子性类型工作起来类似原始类型，不过可以安全的在线程间共享。
        // * 由于线程安全带有性能惩罚, 所以我们只希望在必要的时候才为此买单, 如果在单线程中对值进行操作, 原子性提供的保证务必要, 代码运行速度还会受到影响, 因此并非所有的类型都是原子性的
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());

    /* 
        ? Mutex<T> 提供了内部可变性, 就像Cell系列类型那样
        ?  Rust 不能避免使用 Mutex<T> 的全部逻辑错误, 依然存在死锁风险
    */

    /* 
        有两个并发概念是内嵌于语言中的: std::marker中的Sync和 Send trait
        + 通过 Send 允许在线程间转移所有权
            - Send 标记 trait 表明实现了 Send 的类型值的所有权可以在线程间传送
            - 几乎所有Rust的类型都是Send
                * Rc<T>是个例外, 因为如果克隆了 Rc<T>的值并尝试将克隆的所有权转移到另一个线程, 这两个线程可能同时更新引用计数。所以他被用于单线程场景, 不需要为拥有线程安全的引用计数而付出性能代价
            - Rust 类型系统和 trait bound 确保永远也不会意外的将不安全的 Rc<T> 在线程间发送
            - 任何完全由 Send 的类型组成的类型也会自动被标记为 Send
            - 几乎所有基本类型都是 Send
                * 除了 裸指针(raw pointer)
        + Sync 允许多线程访问
            - Sync 标记 trait 表明一个实现了 Sync 的类型可以安全的在多个线程中拥有其值的引用
            - 对于任意 T, 如果 &T(T是不可变引用) 是 Send 的话, T 就是 Sync的, 意味着其引用就可以安全的发送到另一个线程.
            - 类似于 Send 的情况，基本类型是 Sync 的，完全由 Sync 的类型组成的类型也是 Sync 的
            - 智能指针 Rc<T> 也不是 Sync 的
            - RefCell<T> 和 Cell<T> 系列类型不是 Sync 的
        + 不需要手动实现 Send 和 Sync trait，因为由 Send 和 Sync 的类型组成的类型，自动就是 Send 和 Sync, 他们是标记 trait，甚至都不需要实现任何方法
    
    */
}
